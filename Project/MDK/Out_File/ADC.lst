C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:10:41  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Out_File\ADC.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\USER\src\ADC.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(..\..\Lib
                    -raries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src)
                    - DEBUG PRINT(.\Out_File\ADC.lst) TABS(2) OBJECT(.\Out_File\ADC.obj) 

stmt  level    source

    1          #include "ADC.h"
    2          #include "math.h"
    3          // int16 aim_speeda        = 730;  //ç›®æ ‡é€Ÿåº¦
    4          int16 aim_speedb = 0; // è¾“å‡ºé€Ÿåº¦ï¼ˆåŠ¨æ€æœŸæœ›é€Ÿåº¦ï¼‰=æœŸæœ›é€Ÿåº¦*æœŸæœ›å‡é€Ÿåº¦
    5          int16 aim_speedc = 0; // è½¬å¼¯å‡å°é€Ÿåº¦
    6          
    7          int16 adc_value[4]; // å‚¨å­˜ç”µæ„Ÿé‡‡é›†å€¼åŸå§‹å€¼    4ä¸ªç”µæ„Ÿ
    8          int16 AD_V[4];    // å‚¨å­˜ç”µæ„Ÿé‡‡é›†å€¼å½’ä¸€åŒ–å€¼ä¸­é—´å˜é‡ ï¼ˆæ— éœ€å…³å¿ƒï¼Œè¯·å‹¿åˆ é™¤ï¼‰
    9          // int16 adc_max[4]={90,90,90,95}; //ç”µæ„Ÿé‡‡å€¼æœ€å¤§å€¼ éœ€è¦è‡ªå·±é‡‡é›†
   10          int16 adc_max[4] = {250, 200, 175, 250};        // ç”µæ„Ÿé‡‡å€¼æœ€å¤§å€¼ éœ€è¦è‡ªå·±é‡‡é›†
   11          int16 adc_min[4] = {1, 1, 1, 1};            // ç”µæ„Ÿé‡‡å€¼æœ€å°å€¼  1,4,14,1
   12          uint8 Left_Adc, Right_Adc, Left_Shu_Adc, Right_Shu_Adc; // ç”µæ„Ÿå€¼
   13          float adc_valueM;
   14          int8 NM = 4; // ç”µæ„Ÿä¸ªæ•°
   15          
   16          // ç¯é“å‚æ•°
   17          uint16 annulus_s;
   18          uint16 annulus_s2; // ç¯å²›ç§¯åˆ†è·ç¦»2
   19          uint16 annulus_t;
   20          uint16 annulus_z;
   21          uint16 annulus_s3 = 0; // ç¯å²›ç§¯åˆ†è·ç¦»3
   22          
   23          struct ROAD_TYPE road_type = {0};
   24          int16 obstacle_Current_Dir[] = {
   25            30,
   26            31,
   27            32,
   28            33,
   29            34,
   30            35,
   31            36,
   32            37,
   33            38,
   34            39,
   35            40,
   36            41,
   37            42,
   38            43,
   39            44,
   40            45,
   41            46,
   42            47,
   43            48,
   44            49,
   45            -69,
   46            -68,
   47            -67,
   48            -66,
   49            -65,
   50            -64,
   51            -63,
   52            -62,
   53            -61,
   54            -60,
   55            -59,
   56            -58,
   57            -57,
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:10:41  PAGE 2   

   58            -56,
   59            -55,
   60            -54,
   61            -53,
   62            -52,
   63            -51,
   64            -50,
   65            -49,
   66            -48,
   67            -47,
   68            -46,
   69            -45,
   70            -44,
   71            -43,
   72            -42,
   73            -41,
   74            -40,
   75            -39,
   76            -38,
   77            -37,
   78            -36,
   79            -35,
   80            -34,
   81            -33,
   82            -32,
   83            -31,
   84            -30,
   85          };
   86          /***å½“å‰ä½ç½®*************/
   87          float Current_Dir = 0;
   88          int16 Set_gyro = 0;
   89          int16 ADC_PWM = 0;
   90          
   91          uint8 temp = 0;
   92          /***************************ç”µæ„Ÿé‡‡é›†é€šé“åˆå§‹åŒ–****************************
   93          å‡½æ•°ï¼š  void ADC_int(void)
   94          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼è¿›è¡Œåˆå§‹åŒ–
   95          å‚æ•°ï¼š  void
   96          è¯´æ˜ï¼š  ç”µæ„Ÿé‡‡é›†åˆå§‹åŒ–
   97          è¿”å›å€¼ï¼›æ— 
   98          ************************************************************************/
   99          void ADC_int(void)
  100          {
  101   1        adc_init(Left_ADC_Pin, ADC_SYSclk_DIV_2);   // åˆå§‹åŒ–P0.0ä¸ºADCåŠŸèƒ½
  102   1        adc_init(LeftXie_ADC_Pin, ADC_SYSclk_DIV_2);  // åˆå§‹åŒ–P0.1ä¸ºADCåŠŸèƒ½
  103   1        adc_init(RightXie_ADC_Pin, ADC_SYSclk_DIV_2); // åˆå§‹åŒ–P0.5ä¸ºADCåŠŸèƒ½
  104   1        adc_init(Right_ADC_Pin, ADC_SYSclk_DIV_2);    // åˆå§‹åŒ–P0.6ä¸ºADCåŠŸèƒ½
  105   1      
  106   1        adc_init(Mid_ADC_Pin, ADC_SYSclk_DIV_2); // åˆå§‹åŒ–P1.5ä¸ºADCåŠŸèƒ½
  107   1      }
  108          
  109          /***************************ä¸­å€¼æ»¤æ³¢å‡½æ•°*********************************
  110          å‡½æ•°ï¼šuint16 adc_mid(ADCN_enum adcn,ADCCH_enum ch)
  111          åŠŸèƒ½ï¼š 3æ¬¡ç”µæ„Ÿé‡‡å€¼è¿›è¡Œä¸­å€¼æ»¤æ³¢
  112          å‚æ•°ï¼š adcn        é€‰æ‹©ADCé€šé“       resolution      åˆ†è¾¨ç‡
  113          è¯´æ˜ï¼š 8ä½ADCè¾“å‡ºï¼Œ0~255ï¼ˆ2çš„8æ¬¡æ–¹ï¼‰ï¼Œ5vç”µå‹å¹³å‡åˆ†æˆ255ä»½ï¼Œåˆ†è¾¨ç‡ä¸º5/255=0.196
  114          è¿”å›å€¼ï¼›k(uint8)ä¸­é—´é‚£ä¸ªå€¼
  115          ************************************************************************/
  116          uint16 adc_mid(ADCN_enum adcn, ADCRES_enum ch)
  117          {
  118   1        uint16 i, j, k, tmp;
  119   1        i = adc_once(adcn, ch);
  120   1        j = adc_once(adcn, ch);
  121   1        k = adc_once(adcn, ch);
  122   1        if (i > j)
  123   1        {
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:10:41  PAGE 3   

  124   2          tmp = i, i = j, j = tmp;
  125   2        }
  126   1        if (k > j)
  127   1        {
  128   2          tmp = j;
  129   2        }
  130   1        else if (k > i)
  131   1        {
  132   2          tmp = k;
  133   2        }
  134   1        else
  135   1        {
  136   2          tmp = i;
  137   2        }
  138   1        return (tmp);
  139   1      }
  140          
  141          /***************************å‡å€¼æ»¤æ³¢å‡½æ•°****************************
  142          å‡½æ•°ï¼š  uint16 adc_ave(ADCN_enum adcn,ADCCH_enum ch,uint8 N)
  143          åŠŸèƒ½ï¼š  ä¸­å€¼æ»¤æ³¢åçš„5ä¸ªç”µæ„Ÿå€¼æ±‚å¹³å‡å€¼
  144          å‚æ•°ï¼š  adcn        é€‰æ‹©ADCé€šé“
  145          è¯´æ˜ï¼š  è¯¥å‡½æ•°è°ƒç”¨ä¸­å€¼æ»¤æ³¢å‡½æ•°ï¼Œå³ç”µæ„Ÿå€¼æ˜¯ä¸­ä½ç½®
  146          è¿”å›å€¼ï¼›tmp
  147          ç¤ºä¾‹ï¼š  adc_ave(ADC_P10, ADC_8BIT)-->ADCé€šé“ä¸ºP-10ï¼Œåˆ†è¾¨ç‡ä¸º8bit
  148          *******************************************************************/
  149          uint16 adc_ave(ADCN_enum adcn, ADCRES_enum ch, uint8 N)
  150          {
  151   1        uint32 tmp = 0;
  152   1        uint8 i;
  153   1        for (i = 0; i < N; i++)
  154   1        {
  155   2          tmp += adc_mid(adcn, ch);
  156   2        }
  157   1        tmp = tmp / N;
  158   1        return (tmp);
  159   1      }
  160          /***************************ç”µæ„Ÿé‡‡å€¼************************************
  161          å‡½æ•°ï¼š  void ADC_Collect()
  162          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼
  163          å‚æ•°ï¼š  void
  164          è¯´æ˜ï¼š  8ä½ADCè¾“å‡ºï¼Œ0~255ï¼ˆ2çš„8æ¬¡æ–¹ï¼‰ï¼Œ5vç”µå‹å¹³å‡åˆ†æˆ255ä»½ï¼Œåˆ†è¾¨ç‡ä¸º5/255=0.196
  165          è¿”å›å€¼ï¼›void
  166          ***********************************************************************/
  167          void ADC_Collect()
  168          {
  169   1        adc_value[0] = adc_ave(Left_ADC_Pin, ADC_8BIT, 3);     // å·¦æ¨ªç”µæ„Ÿ
  170   1        adc_value[1] = adc_ave(LeftXie_ADC_Pin, ADC_8BIT, 3);  // å·¦ç«–ç”µæ„Ÿ
  171   1        adc_value[2] = adc_ave(RightXie_ADC_Pin, ADC_8BIT, 3);   // å³ç«–ç”µæ„Ÿ
  172   1        adc_value[3] = adc_ave(Right_ADC_Pin, ADC_8BIT, 3);    // å³æ¨ªç”µæ„Ÿ
  173   1        adc_valueM = adc_ave(Mid_ADC_Pin, ADC_8BIT, 3) * 0.2246; // ç”µæºç”µå‹é‡‡é›†
  174   1      }
  175          /*********************************ç”µæ„Ÿé‡‡å€¼********************************
  176          å‡½æ•°ï¼š  void Data_current_analyze()
  177          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼åŸå§‹å€¼å½’ä¸€åŒ–ï¼ˆ0~100ï¼‰
  178          å‚æ•°ï¼š  void
  179          è¯´æ˜ï¼š  å½’ä¸€åŒ–å¤„ç†
  180          è¿”å›å€¼ï¼›void
  181          *************************************************************************/
  182          void Data_current_analyze()
  183          {
  184   1        uint8 i;
  185   1        for (i = 0; i < NM; i++)
  186   1        {
  187   2          AD_V[i] = ((adc_value[i] - adc_min[i]) * 100) / (adc_max[i] - adc_min[i]);
  188   2          if (AD_V[i] <= 0)
  189   2          {
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:10:41  PAGE 4   

  190   3            AD_V[i] = 0;
  191   3          }
  192   2          else if (AD_V[i] >= 100)
  193   2          {
  194   3            AD_V[i] = 100;
  195   3          }
  196   2        }
  197   1        Left_Adc = AD_V[0];    // å·¦ç”µæ„Ÿæœ€ç»ˆå€¼
  198   1        Left_Shu_Adc = AD_V[1];  // å·¦ç«–ç”µæ„Ÿæœ€ç»ˆå€¼
  199   1        Right_Shu_Adc = AD_V[2]; // å³ç«–ç”µæ„Ÿæœ€ç»ˆå€¼
  200   1        Right_Adc = AD_V[3];   // å³ç”µæ„Ÿæœ€ç»ˆå€¼
  201   1      }
  202          
  203          /*********************************å·®æ¯”å’Œå‡½æ•°**********************************
  204          å‡½æ•°ï¼š  float Cha_bi_he(int16 data1, int16 data2,int16 x)
  205          åŠŸèƒ½ï¼š  å·®æ¯”å’Œæ±‚èµ›é“åå·®
  206          å‚æ•°ï¼š  int16 data1, int16 data2,int16 x
  207          è¯´æ˜ï¼š  å·®æ¯”å’Œæ±‚èµ›é“åå·®
  208          è¿”å›å€¼ï¼›result
  209          ****************************************************************************/
  210          float Cha_bi_he(int16 data1, int16 data2, int16 x)
  211          {
  212   1        float cha;
  213   1        float he;
  214   1        float result;
  215   1      
  216   1        cha = (data1) - (data2);
  217   1        he = data1 + data2 + 1;
  218   1        result = (cha * x) / (1.0 * he);
  219   1      
  220   1        return result;
  221   1      }
  222          // å·®æ¯”å’Œå·®åŠ æƒï¼Œå˜å¼
  223          float Cha_bi_he_cha(int16 data1, int16 data2, int16 data3, int16 data4, int16 x, int16 y)
  224          {
  225   1        float cha;
  226   1        float he;
  227   1        float cha1;
  228   1        float he1;
  229   1      
  230   1        float result;
  231   1      
  232   1        cha = (data1) - (data2);
  233   1        cha1 = (data3) - (data4);
  234   1      
  235   1        he = data1 + data2 + 1;
  236   1        he1 = data3 + data4 + 1;
  237   1      
  238   1        //    result = (cha*x)/(1.0*he);
  239   1        result = ((cha * x) + (cha1 * y)) / ((1.0 * he) + (1.0 * he1));
  240   1        return result;
  241   1      }
  242          // å‘é‡å·®æ¯”å’Œ
  243          float Cha_x_bi_he(int16 data1, int16 data2, int16 data3, int16 data4)
  244          {
  245   1        float left_value;
  246   1        float right_value;
  247   1        float ad_sum;
  248   1        float ad_diff;
  249   1        float error_x;
  250   1        left_value = sqrt(data1 * data1 + data2 * data2);
  251   1      
  252   1        right_value = sqrt(data3 * data3 + data4 * data4);
  253   1      
  254   1        ad_sum = left_value + right_value + 1; // è®¡ç®—ç”µæ„Ÿä¹‹å’Œ
  255   1      
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:10:41  PAGE 5   

  256   1        // è®¡ç®—ç”µæ„Ÿä¹‹å·®
  257   1      
  258   1        ad_diff = (int16)right_value - left_value;
  259   1        error_x = ad_diff / ad_sum;
  260   1      
  261   1        return error_x;
  262   1      }
  263          /*****************************************å‡ºç•Œä¿æŠ¤å‡½æ•°*************************************
  264          å‡½æ•°ï¼š  void Out_protect()
  265          å‚æ•°ï¼š  æ— 
  266          è¯´æ˜ï¼š  é˜²æ­¢è½¦å†²å‡ºèµ›é“åæ’åä¸œè¥¿,æ£€æµ‹å‡ºèµ›é“åä¸­æ–­å¤±èƒ½ï¼Œç”µæœºåœè½¬ï¼Œæ”¾å›èµ›
             -é“ä¸­æ–­ä½¿èƒ½ç»§ç»­è·‘
  267          
  268          *æ³¨æ„ï¼šï¼ï¼ï¼å¹³æ—¶è°ƒè¯•æ—¶å¯ä»¥æ‰“å¼€ï¼ŒåŠ äº†é¿éšœå¤„ç†åéœ€è¦å…³é—­æ­¤å‡½æ•°ï¼Œä¸ç„¶æœ‰å
             -¯èƒ½æ— æ³•å®ç°é¿éšœåŠŸèƒ½ï¼ï¼ï¼
  269          è¿”å›å€¼ï¼šæ— 
  270          ******************************************************************************************/
  271          void Out_protect(void)
  272          {
  273   1        if (road_type.annulus || road_type.in_annulus_left || road_type.in_annulus_right || road_type.on_annulus
             -_left || road_type.on_annulus_right || road_type.out_annulus)
  274   1        {
  275   2          if (Left_Adc < OUTSIDE || Right_Adc < OUTSIDE)
  276   2          {
  277   3            while (1)
  278   3            {
  279   4              go_motor(-2000, -2000);
  280   4              delay_ms(400);
  281   4              while (1)
  282   4              {
  283   5                go_motor(0, 0);
  284   5                pwm_duty(PWMB_CH4_P77, 500);
  285   5                pwm_duty(PWMB_CH3_P33, 500);
  286   5              }
  287   4            }
  288   3          }
  289   2        }
  290   1      }
  291          
  292          void Annulus_assist(void)
  293          {
  294   1        if (road_type.annulus == 1 && road_type.in_annulus_right == 0 && road_type.on_annulus_right == 0 && road
             -_type.out_annulus == 0) //&&road_type.in_annulus_left==0
  295   1        {
  296   2          annulus_s += fabs(last_speed) * 1;
  297   2        }
  298   1        if (road_type.in_annulus_right == 1) // road_type.in_annulus_left==1 ||                 && road_type.on_
             -annulus_left==0ï¿½ï¿½ï¿½â£©&& road_type.on_annulus_right==0
  299   1        {
  300   2          annulus_z += fabs(GORY_Z);
  301   2          annulus_s2 += fabs(last_speed) * 1; // ï¿½ï¿½ï¿½İ»ï¿½ï¿½Ö¾ï¿½ï¿½ï¿½Í±ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµï¿½ï¿½ï¿½Ä£
             -ï¿½0.1ï¿½ï¿½
  302   2        }
  303   1        if (road_type.on_annulus_right == 1) // road_type.in_annulus_left==1 ||                 && road_type.on_
             -annulus_left==0ï¿½ï¿½ï¿½â£©&& road_type.on_annulus_right==0
  304   1        {
  305   2          //        annulus_z += fabs(GORY_Z);
  306   2          annulus_s3 += fabs(last_speed) * 1; // ï¿½ï¿½ï¿½İ»ï¿½ï¿½Ö¾ï¿½ï¿½ï¿½Í±ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµï¿½ï¿½ï¿½Ä£
             -ï¿½0.1ï¿½ï¿½
  307   2        }
  308   1        if (road_type.out_annulus == 1)
  309   1        {
  310   2          annulus_t = fabs(last_speed) * 1;
  311   2          //          annulus_t=annulus_t+5;
  312   2        }
  313   1      }
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:10:41  PAGE 6   

  314          
  315          int8 testflag;
  316          /*************************************ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*******************************
             -******
  317          å‡½æ•°ï¼š  void Annulus_handle(void)
  318          å‚æ•°ï¼š  æ— 
  319          è¯´æ˜ï¼š  ç¯å²›å¤„ç†å‡½æ•°
  320          
  321          *æ³¨æ„ï¼šç”¨ä¸¤ä¸ªç«–ç”µæ„Ÿå¼•å¯¼è¿›ç¯
  322          è¿”å›å€¼ï¼šæ— 
  323          ******************************************************************************************/
  324          void Annulus_handle(void)
  325          {
  326   1        if ((Left_Adc + Right_Adc) > IN_ANNULUS_H_LIMIT && road_type.annulus == 0)
  327   1        {
  328   2          testflag = 1;
  329   2          road_type.annulus = 1;
  330   2          BUZZ_ON;
  331   2        }
  332   1        //    //å·¦ç¯è¿›ç¯åˆ¤æ–­
  333   1        //    if(annulus_s > DISTANCE_ANNULUS_S
  334   1        //       &&(Left_Shu_Adc>20)
  335   1        //       &&road_type.annulus==1
  336   1        //       &&road_type.in_annulus_left==0
  337   1        //       &&road_type.in_annulus_right==0
  338   1        //       &&road_type.on_annulus_left==0
  339   1        //       &&road_type.on_annulus_right==0
  340   1        //       &&road_type.out_annulus==0)
  341   1        //    {
  342   1        //      road_type.in_annulus_left = 1;
  343   1        //      P52                      = 0;
  344   1        //      testflag = 2;
  345   1        //    }
  346   1        // å³ç¯è¿›ç¯åˆ¤æ–­
  347   1        if (annulus_s > DISTANCE_ANNULUS_S
  348   1          //    && (Right_Shu_Adc > 20)
  349   1          && road_type.annulus == 1 && road_type.in_annulus_left == 0 && road_type.in_annulus_right == 0 && road_
             -type.on_annulus_left == 0 && road_type.on_annulus_right == 0 && road_type.out_annulus == 0)
  350   1        {
  351   2          testflag = 3;
  352   2          road_type.in_annulus_right = 1;
  353   2          BUZZ_ON;
  354   2        }
  355   1        //    //å·¦ç¯ä¸Šç¯å¤„ç†
  356   1        //    if(annulus_s2 > 40
  357   1        ////       &&annulus_z > DISTANCE_ANNULUS_Z
  358   1        //       &&road_type.annulus==1
  359   1        //       &&road_type.in_annulus_left==1
  360   1        //       &&road_type.in_annulus_right==0
  361   1        //       &&road_type.on_annulus_left==0
  362   1        //       &&road_type.on_annulus_right==0
  363   1        //       &&road_type.out_annulus==0)
  364   1        //    {
  365   1        //        testflag = 4;
  366   1        //        road_type.in_annulus_left =0;
  367   1        //        road_type.on_annulus_left = 1;
  368   1        //        BUZZ_ON;
  369   1        //        P52                      = 1;
  370   1        //    }
  371   1        // å³ç¯ä¸Šç¯å¤„ç†
  372   1        if (annulus_s2 > 1300 && road_type.annulus == 1 && road_type.in_annulus_left == 0 && road_type.in_annulu
             -s_right == 1 && road_type.on_annulus_left == 0 && road_type.on_annulus_right == 0 && road_type.out_annulus == 0)
  373   1        {
  374   2          testflag = 5;
  375   2          road_type.in_annulus_right = 0;
  376   2          road_type.on_annulus_right = 1;
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:10:41  PAGE 7   

  377   2          BUZZ_ON;
  378   2        }
  379   1        if (((road_type.on_annulus_right == 1) 
  380   1        || (road_type.on_annulus_left == 1)) 
  381   1        && Left_Adc + Right_Adc > OUT_ANNULUS_S_LIMIT 
  382   1        && annulus_s3 > 200)
  383   1        {
  384   2          testflag = 6;
  385   2          road_type.on_annulus_right = 0;
  386   2          road_type.on_annulus_left = 0;
  387   2          road_type.out_annulus = 1;
  388   2          annulus_s = 0;
  389   2          annulus_z = 0;
  390   2          annulus_s2 = 0;
  391   2          BUZZ_ON;
  392   2        }
  393   1        // å‡ºç¯å¤„ç†
  394   1        if (annulus_t > DISTANCE_ANNULUS_T 
  395   1          && road_type.out_annulus == 1)
  396   1        {
  397   2          testflag = 7;
  398   2          road_type.out_annulus = 0;
  399   2          annulus_t = 0;
  400   2          BUZZ_OFF;
  401   2          //          while(1)
  402   2          //          {
  403   2          //            go_motor(0,0);
  404   2          //          }
  405   2        }
  406   1      
  407   1        // if (annulus_t > DISTANCE_ANNULUS_T)
  408   1        // {
  409   1        //  road_type.annulus = 0;
  410   1        //  road_type.in_annulus_left = 0;
  411   1        //  road_type.in_annulus_right = 0;
  412   1        //  road_type.on_annulus_left = 0;
  413   1        //  road_type.on_annulus_right = 0;
  414   1        //  road_type.out_annulus = 0;
  415   1        //  annulus_t = 0;
  416   1      
  417   1        //  BUZZ_OFF;
  418   1        // }
  419   1      }
  420          /*************************æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®è®¡ç®—æ–¹æ³•**********************
             -***
  421          å‡½æ•°ï¼š  int16 Direction_error(void)
  422          åŠŸèƒ½ï¼š  æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®
  423          å‚æ•°ï¼š  æ— 
  424          è¯´æ˜ï¼š  æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®
  425          è¿”å›å€¼ï¼šerror--è¿”å›èµ›é“åå·®
  426          ****************************************************************************************/
  427          float Direction_error(void)
  428          {
  429   1        float error = 0;
  430   1      
  431   1        // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  432   1        if (road_type.annulus == 1)
  433   1        {
  434   2          // ×¼ï¿½ï¿½ï¿½ë»·ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  435   2          //        if(road_type.annulus==1&&road_type.in_annulus_left==0 && road_type.in_annulus_right==0 && roa
             -d_type.on_annulus_left==0 && road_type.on_annulus_right==0 && road_type.out_annulus==0)
  436   2          //        {
  437   2          //          error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*20;
  438   2          //        //ï¿½ï¿½ï¿½ó»·µï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  439   2          //        if(road_type.in_annulus_left ==1 && road_type.on_annulus_left==0 )
  440   2          //        {
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:10:41  PAGE 8   

  441   2          //            //error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*20;
  442   2          //            error = -15;
  443   2          //          road_type.annulus=0;//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö¾Î»ï¿½ï¿½ï¿½ï¿½
  444   2          //        }
  445   2          // ï¿½ï¿½ï¿½Ò»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  446   2          if (road_type.in_annulus_right == 1 )
  447   2          {
  448   3            // error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*20;          // error = 3;
  449   3            error = 0.5; // ï¿½ß¼ï¿½ï¿½à·´ï¿½ï¿½Ñ­ï¿½ï¿½
  450   3      
  451   3            //        while(1)//ï¿½ï¿½Ç½Úµï¿½2
  452   3            //          {
  453   3            //            go_motor(0,0);
  454   3            //          }
  455   3          }
  456   2          // ï¿½Ú»ï¿½ï¿½ï¿½Æ«ï¿½ï¿½
  457   2          if (road_type.on_annulus_right == 1)
  458   2          {
  459   3            road_type.annulus = 0; // ï¿½ë»·ï¿½ï¿½ï¿½ï¿½Ö¾Î»ï¿½ï¿½ï¿½ï¿½
  460   3            road_type.in_annulus_right = 0;
  461   3            //          error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*20;
  462   3            error = (Cha_bi_he(Right_Adc, Left_Adc, 20));
  463   3      
  464   3            //        while(1)//ï¿½ï¿½ï¿½ï¿½Ñ­ï¿½ï¿½ï¿½Úµï¿½4
  465   3            //          {
  466   3            //            go_motor(0,0);
  467   3            //          }
  468   3          }
  469   2          // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  470   2          if (road_type.out_annulus == 1 && road_type.on_annulus_right == 1)
  471   2          {
  472   3            //            error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*7;
  473   3            error = -3;
  474   3            //          error = Cha_bi_he(Right_Adc,Left_Adc,5);
  475   3            road_type.annulus = 0; // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö¾Î»ï¿½ï¿½ï¿½ï¿½
  476   3                         //       while(1)//ï¿½ï¿½ï¿½ï¿½ï¿½Úµï¿½6
  477   3                         //         {
  478   3                         //           go_motor(0,0);
  479   3                         //         }
  480   3          }
  481   2        }
  482   1        // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½î´¦ï¿½ï¿½
  483   1      
  484   1        else
  485   1        {
  486   2      
  487   2          //    aim_speed = ZxjsWdjs(Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc),400)+100;
  488   2          error = Cha_x_bi_he(Left_Adc, Left_Shu_Adc * 2, Right_Adc, Right_Shu_Adc * 2) * 20; // ï¿½ï¿½Ä»ï¿½ï¿½Ê¾
             -ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½Öµ
  489   2      
  490   2          //      errorh=1.0f/exp(errors*errors);                       //ï¿½ï¿½ï¿½Ùºï¿½ï¿½ï¿½
  491   2          //      aim_speedb=aim_speed*errorh;                        //ï¿½ï¿½Ì¬ï¿½ï¿½ï¿½ï¿½ï¿½Ù¶È£ï¿½Ö±ï¿½ï¿½ï¿½ï¿½Ë¥ï¿½ï¿½ï¿½ï
             -¿½ï¿½Ë¥ï¿½ï¿½ï¿½ï¿½
  492   2                      //      if(Left_Adc==0&&Left_Shu_Adc==0&&Right_Adc==0&&Right_Shu_Adc==0)
  493   2                      //      {
  494   2                      //      aim_speedb = -10;                             //ï¿½ï¿½ï¿½ßµï¿½ï¿½ï¿½
  495   2                      //      }
  496   2      
  497   2          //  }
  498   2        }
  499   1        return error;
  500   1      }
  501          
  502          /**********************************ç”µç£æ‰€æœ‰æ€»å¤„ç†***************************************
  503          å‡½æ•°ï¼š  void Get_deviation(void)
  504          åŠŸèƒ½ï¼š  ç”µç£æ‰€æœ‰æ€»å¤„ç†
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:10:41  PAGE 9   

  505          å‚æ•°ï¼š  æ— 
  506          è¯´æ˜ï¼š  æ”¾ä¸­æ–­è°ƒç”¨æ­¤å‡½æ•°å³å¯
  507          è¿”å›å€¼ï¼šæ— 
  508          ****************************************************************************************/
  509          void Get_deviation(void)
  510          {
  511   1      
  512   1        ADC_Collect();           
  513   1        Data_current_analyze();      
  514   1        Annulus_handle();        
  515   1        Annulus_assist();        
  516   1        Current_Dir = Direction_error(); 
  517   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1395     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       194         20
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       209     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
