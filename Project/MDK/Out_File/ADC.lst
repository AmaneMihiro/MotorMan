C251 COMPILER V5.60.0,  ADC                                                                20/03/25  23:56:15  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Out_File\ADC.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\USER\src\ADC.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(..\..\Lib
                    -raries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src)
                    - DEBUG PRINT(.\Out_File\ADC.lst) TABS(2) OBJECT(.\Out_File\ADC.obj) 

stmt  level    source

    1          #include "ADC.h"
    2          #include "math.h"
    3          // int16 aim_speeda        = 730;  //ç›®æ ‡é€Ÿåº¦
    4          int16 aim_speedb = 0; // è¾“å‡ºé€Ÿåº¦ï¼ˆåŠ¨æ€æœŸæœ›é€Ÿåº¦ï¼‰=æœŸæœ›é€Ÿåº¦*æœŸæœ›å‡é€Ÿåº¦
    5          int16 aim_speedc = 0; // è½¬å¼¯å‡å°é€Ÿåº¦
    6          
    7          int16 adc_value[4]; // å‚¨å­˜ç”µæ„Ÿé‡‡é›†å€¼åŸå§‹å€¼    4ä¸ªç”µæ„Ÿ
    8          int16 AD_V[4];    // å‚¨å­˜ç”µæ„Ÿé‡‡é›†å€¼å½’ä¸€åŒ–å€¼ä¸­é—´å˜é‡ ï¼ˆæ— éœ€å…³å¿ƒï¼Œè¯·å‹¿åˆ é™¤ï¼‰
    9          // int16 adc_max[4]={90,90,90,95}; //ç”µæ„Ÿé‡‡å€¼æœ€å¤§å€¼ éœ€è¦è‡ªå·±é‡‡é›†
   10          int16 adc_max[4] = {250, 200, 175, 250};        // ç”µæ„Ÿé‡‡å€¼æœ€å¤§å€¼ éœ€è¦è‡ªå·±é‡‡é›†
   11          int16 adc_min[4] = {1, 1, 1, 1};            // ç”µæ„Ÿé‡‡å€¼æœ€å°å€¼  1,4,14,1
   12          uint8 Left_Adc = 0;
   13          uint8 Right_Adc = 0;
   14          uint8 Left_Shu_Adc = 0;
   15          uint8 Right_Shu_Adc = 0;// ç”µæ„Ÿå€¼
   16          float adc_valueM;
   17          int8 NM = 4; // ç”µæ„Ÿä¸ªæ•°
   18          
   19          //ç¼–ç å™¨å€¼è½¬çœŸå®è·ç¦»ä¸º1280è½¬40cm
   20          
   21          // ç¯é“å‚æ•°
   22          uint16 annulus_s;
   23          uint16 annulus_s2; // ç¯å²›ç§¯åˆ†è·ç¦»2
   24          uint16 annulus_s3; // ç¯å²›ç§¯åˆ†è·ç¦»3
   25          uint16 annulus_t;
   26          uint16 annulus_z;
   27          
   28          
   29          struct ROAD_TYPE road_type = {0};
   30          int16 obstacle_Current_Dir[] = {
   31            30,
   32            31,
   33            32,
   34            33,
   35            34,
   36            35,
   37            36,
   38            37,
   39            38,
   40            39,
   41            40,
   42            41,
   43            42,
   44            43,
   45            44,
   46            45,
   47            46,
   48            47,
   49            48,
   50            49,
   51            -69,
   52            -68,
   53            -67,
   54            -66,
   55            -65,
   56            -64,
   57            -63,
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  23:56:15  PAGE 2   

   58            -62,
   59            -61,
   60            -60,
   61            -59,
   62            -58,
   63            -57,
   64            -56,
   65            -55,
   66            -54,
   67            -53,
   68            -52,
   69            -51,
   70            -50,
   71            -49,
   72            -48,
   73            -47,
   74            -46,
   75            -45,
   76            -44,
   77            -43,
   78            -42,
   79            -41,
   80            -40,
   81            -39,
   82            -38,
   83            -37,
   84            -36,
   85            -35,
   86            -34,
   87            -33,
   88            -32,
   89            -31,
   90            -30,
   91          };
   92          /***å½“å‰ä½ç½®*************/
   93          float Current_Dir = 0;
   94          int16 Set_gyro = 0;
   95          int16 ADC_PWM = 0;
   96          
   97          uint8 temp = 0;
   98          /***************************ç”µæ„Ÿé‡‡é›†é€šé“åˆå§‹åŒ–****************************
   99          å‡½æ•°ï¼š  void ADC_int(void)
  100          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼è¿›è¡Œåˆå§‹åŒ–
  101          å‚æ•°ï¼š  void
  102          è¯´æ˜ï¼š  ç”µæ„Ÿé‡‡é›†åˆå§‹åŒ–
  103          è¿”å›å€¼ï¼›æ— 
  104          ************************************************************************/
  105          void ADC_int(void)
  106          {
  107   1        adc_init(Left_ADC_Pin, ADC_SYSclk_DIV_2);   // åˆå§‹åŒ–P0.0ä¸ºADCåŠŸèƒ½
  108   1        adc_init(LeftXie_ADC_Pin, ADC_SYSclk_DIV_2);  // åˆå§‹åŒ–P0.1ä¸ºADCåŠŸèƒ½
  109   1        adc_init(RightXie_ADC_Pin, ADC_SYSclk_DIV_2); // åˆå§‹åŒ–P0.5ä¸ºADCåŠŸèƒ½
  110   1        adc_init(Right_ADC_Pin, ADC_SYSclk_DIV_2);    // åˆå§‹åŒ–P0.6ä¸ºADCåŠŸèƒ½
  111   1      
  112   1        adc_init(Mid_ADC_Pin, ADC_SYSclk_DIV_2); // åˆå§‹åŒ–P1.5ä¸ºADCåŠŸèƒ½
  113   1      }
  114          
  115          /***************************ä¸­å€¼æ»¤æ³¢å‡½æ•°*********************************
  116          å‡½æ•°ï¼šuint16 adc_mid(ADCN_enum adcn,ADCCH_enum ch)
  117          åŠŸèƒ½ï¼š 3æ¬¡ç”µæ„Ÿé‡‡å€¼è¿›è¡Œä¸­å€¼æ»¤æ³¢
  118          å‚æ•°ï¼š adcn        é€‰æ‹©ADCé€šé“       resolution      åˆ†è¾¨ç‡
  119          è¯´æ˜ï¼š 8ä½ADCè¾“å‡ºï¼Œ0~255ï¼ˆ2çš„8æ¬¡æ–¹ï¼‰ï¼Œ5vç”µå‹å¹³å‡åˆ†æˆ255ä»½ï¼Œåˆ†è¾¨ç‡ä¸º5/255=0.196
  120          è¿”å›å€¼ï¼›k(uint8)ä¸­é—´é‚£ä¸ªå€¼
  121          ************************************************************************/
  122          uint16 adc_mid(ADCN_enum adcn, ADCRES_enum ch)
  123          {
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  23:56:15  PAGE 3   

  124   1        uint16 i, j, k, tmp;
  125   1        i = adc_once(adcn, ch);
  126   1        j = adc_once(adcn, ch);
  127   1        k = adc_once(adcn, ch);
  128   1        if (i > j)
  129   1        {
  130   2          tmp = i, i = j, j = tmp;
  131   2        }
  132   1        if (k > j)
  133   1        {
  134   2          tmp = j;
  135   2        }
  136   1        else if (k > i)
  137   1        {
  138   2          tmp = k;
  139   2        }
  140   1        else
  141   1        {
  142   2          tmp = i;
  143   2        }
  144   1        return (tmp);
  145   1      }
  146          
  147          /***************************å‡å€¼æ»¤æ³¢å‡½æ•°****************************
  148          å‡½æ•°ï¼š  uint16 adc_ave(ADCN_enum adcn,ADCCH_enum ch,uint8 N)
  149          åŠŸèƒ½ï¼š  ä¸­å€¼æ»¤æ³¢åçš„5ä¸ªç”µæ„Ÿå€¼æ±‚å¹³å‡å€¼
  150          å‚æ•°ï¼š  adcn        é€‰æ‹©ADCé€šé“
  151          è¯´æ˜ï¼š  è¯¥å‡½æ•°è°ƒç”¨ä¸­å€¼æ»¤æ³¢å‡½æ•°ï¼Œå³ç”µæ„Ÿå€¼æ˜¯ä¸­ä½ç½®
  152          è¿”å›å€¼ï¼›tmp
  153          ç¤ºä¾‹ï¼š  adc_ave(ADC_P10, ADC_8BIT)-->ADCé€šé“ä¸ºP-10ï¼Œåˆ†è¾¨ç‡ä¸º8bit
  154          *******************************************************************/
  155          uint16 adc_ave(ADCN_enum adcn, ADCRES_enum ch, uint8 N)
  156          {
  157   1        uint32 tmp = 0;
  158   1        uint8 i;
  159   1        for (i = 0; i < N; i++)
  160   1        {
  161   2          tmp += adc_mid(adcn, ch);
  162   2        }
  163   1        tmp = tmp / N;
  164   1        return (tmp);
  165   1      }
  166          /***************************ç”µæ„Ÿé‡‡å€¼************************************
  167          å‡½æ•°ï¼š  void ADC_Collect()
  168          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼
  169          å‚æ•°ï¼š  void
  170          è¯´æ˜ï¼š  8ä½ADCè¾“å‡ºï¼Œ0~255ï¼ˆ2çš„8æ¬¡æ–¹ï¼‰ï¼Œ5vç”µå‹å¹³å‡åˆ†æˆ255ä»½ï¼Œåˆ†è¾¨ç‡ä¸º5/255=0.196
  171          è¿”å›å€¼ï¼›void
  172          ***********************************************************************/
  173          void ADC_Collect()
  174          {
  175   1        adc_value[0] = adc_ave(Left_ADC_Pin, ADC_8BIT, 3);     // å·¦æ¨ªç”µæ„Ÿ
  176   1        adc_value[1] = adc_ave(LeftXie_ADC_Pin, ADC_8BIT, 3);  // å·¦ç«–ç”µæ„Ÿ
  177   1        adc_value[2] = adc_ave(RightXie_ADC_Pin, ADC_8BIT, 3);   // å³ç«–ç”µæ„Ÿ
  178   1        adc_value[3] = adc_ave(Right_ADC_Pin, ADC_8BIT, 3);    // å³æ¨ªç”µæ„Ÿ
  179   1        adc_valueM = adc_ave(Mid_ADC_Pin, ADC_8BIT, 3) * 0.2246; // ç”µæºç”µå‹é‡‡é›†
  180   1      }
  181          /*********************************ç”µæ„Ÿé‡‡å€¼********************************
  182          å‡½æ•°ï¼š  void Data_current_analyze()
  183          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼åŸå§‹å€¼å½’ä¸€åŒ–ï¼ˆ0~100ï¼‰
  184          å‚æ•°ï¼š  void
  185          è¯´æ˜ï¼š  å½’ä¸€åŒ–å¤„ç†
  186          è¿”å›å€¼ï¼›void
  187          *************************************************************************/
  188          void Data_current_analyze()
  189          {
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  23:56:15  PAGE 4   

  190   1        uint8 i;
  191   1        for (i = 0; i < NM; i++)
  192   1        {
  193   2          AD_V[i] = ((adc_value[i] - adc_min[i]) * 100) / (adc_max[i] - adc_min[i]);
  194   2          if (AD_V[i] <= 0)
  195   2          {
  196   3            AD_V[i] = 0;
  197   3          }
  198   2          else if (AD_V[i] >= 100)
  199   2          {
  200   3            AD_V[i] = 100;
  201   3          }
  202   2        }
  203   1        Left_Adc = AD_V[0];    // å·¦ç”µæ„Ÿæœ€ç»ˆå€¼
  204   1        Left_Shu_Adc = AD_V[1];  // å·¦ç«–ç”µæ„Ÿæœ€ç»ˆå€¼
  205   1        Right_Shu_Adc = AD_V[2]; // å³ç«–ç”µæ„Ÿæœ€ç»ˆå€¼
  206   1        Right_Adc = AD_V[3];   // å³ç”µæ„Ÿæœ€ç»ˆå€¼
  207   1      }
  208          
  209          /*********************************å·®æ¯”å’Œå‡½æ•°**********************************
  210          å‡½æ•°ï¼š  float Cha_bi_he(int16 data1, int16 data2,int16 x)
  211          åŠŸèƒ½ï¼š  å·®æ¯”å’Œæ±‚èµ›é“åå·®
  212          å‚æ•°ï¼š  int16 data1, int16 data2,int16 x
  213          è¯´æ˜ï¼š  å·®æ¯”å’Œæ±‚èµ›é“åå·®
  214          è¿”å›å€¼ï¼›result
  215          ****************************************************************************/
  216          float Cha_bi_he(int16 data1, int16 data2, int16 x)
  217          {
  218   1        float cha;
  219   1        float he;
  220   1        float result;
  221   1      
  222   1        cha = (data1) - (data2);
  223   1        he = data1 + data2 + 1;
  224   1        result = (cha * x) / (1.0 * he);
  225   1      
  226   1        return result;
  227   1      }
  228          // å·®æ¯”å’Œå·®åŠ æƒï¼Œå˜å¼
  229          float Cha_bi_he_cha(int16 data1, int16 data2, int16 data3, int16 data4, int16 x, int16 y)
  230          {
  231   1        float cha;
  232   1        float he;
  233   1        float cha1;
  234   1        float he1;
  235   1      
  236   1        float result;
  237   1      
  238   1        cha = (data1) - (data2);
  239   1        cha1 = (data3) - (data4);
  240   1      
  241   1        he = data1 + data2 + 1;
  242   1        he1 = data3 + data4 + 1;
  243   1      
  244   1        //    result = (cha*x)/(1.0*he);
  245   1        result = ((cha * x) + (cha1 * y)) / ((1.0 * he) + (1.0 * he1));
  246   1        return result;
  247   1      }
  248          // å‘é‡å·®æ¯”å’Œ
  249          float Cha_x_bi_he(int16 data1, int16 data2, int16 data3, int16 data4)
  250          {
  251   1        float left_value;
  252   1        float right_value;
  253   1        float ad_sum;
  254   1        float ad_diff;
  255   1        float error_x;
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  23:56:15  PAGE 5   

  256   1        left_value = sqrt(data1 * data1 + data2 * data2);
  257   1      
  258   1        right_value = sqrt(data3 * data3 + data4 * data4);
  259   1      
  260   1        ad_sum = left_value + right_value + 1; // è®¡ç®—ç”µæ„Ÿä¹‹å’Œ
  261   1      
  262   1        // è®¡ç®—ç”µæ„Ÿä¹‹å·®
  263   1      
  264   1        ad_diff = (int16)right_value - left_value;
  265   1        error_x = ad_diff / ad_sum;
  266   1      
  267   1        return error_x;
  268   1      }
  269          /*****************************************å‡ºç•Œä¿æŠ¤å‡½æ•°*************************************
  270          å‡½æ•°ï¼š  void Out_protect()
  271          å‚æ•°ï¼š  æ— 
  272          è¯´æ˜ï¼š  é˜²æ­¢è½¦å†²å‡ºèµ›é“åæ’åä¸œè¥¿,æ£€æµ‹å‡ºèµ›é“åä¸­æ–­å¤±èƒ½ï¼Œç”µæœºåœè½¬ï¼Œæ”¾å›èµ›
             -é“ä¸­æ–­ä½¿èƒ½ç»§ç»­è·‘
  273          
  274          *æ³¨æ„ï¼šï¼ï¼ï¼å¹³æ—¶è°ƒè¯•æ—¶å¯ä»¥æ‰“å¼€ï¼ŒåŠ äº†é¿éšœå¤„ç†åéœ€è¦å…³é—­æ­¤å‡½æ•°ï¼Œä¸ç„¶æœ‰å
             -¯èƒ½æ— æ³•å®ç°é¿éšœåŠŸèƒ½ï¼ï¼ï¼
  275          è¿”å›å€¼ï¼šæ— 
  276          ******************************************************************************************/
  277          void Out_protect(void)
  278          {
  279   1        if (road_type.annulus || road_type.in_annulus_left || road_type.in_annulus_right || road_type.on_annulus
             -_left || road_type.on_annulus_right || road_type.out_annulus)
  280   1        {
  281   2          if (Left_Adc < OUTSIDE || Right_Adc < OUTSIDE)
  282   2          {
  283   3            testflag = 100;
  284   3            while (1)
  285   3            {
  286   4              go_motor(-2000, -2000);
  287   4              delay_ms(400);
  288   4              while (1)
  289   4              {
  290   5                go_motor(0, 0);
  291   5              }
  292   4            }
  293   3          }
  294   2        }
  295   1      }
  296          
  297          void Annulus_assist(void)
  298          {
  299   1        if (road_type.annulus == 1 && road_type.in_annulus_right == 0 && road_type.on_annulus_right == 0 && road
             -_type.out_annulus == 0) //&&road_type.in_annulus_left==0
  300   1        {
  301   2          annulus_s += fabs(last_speed) * 1;
  302   2        }
  303   1        if (road_type.in_annulus_right == 1) // road_type.in_annulus_left==1 ||                 && road_type.on_
             -annulus_left==0ï¿½ï¿½ï¿½â£©&& road_type.on_annulus_right==0
  304   1        {
  305   2          // annulus_z += fabs(GORY_Z);
  306   2          annulus_s2 += fabs(last_speed) * 1; // ï¿½ï¿½ï¿½İ»ï¿½ï¿½Ö¾ï¿½ï¿½ï¿½Í±ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµï¿½ï¿½ï¿½Ä£
             -ï¿½0.1ï¿½ï¿½
  307   2        }
  308   1        if (road_type.on_annulus_right == 1) // road_type.in_annulus_left==1 ||                 && road_type.on_
             -annulus_left==0ï¿½ï¿½ï¿½â£©&& road_type.on_annulus_right==0
  309   1        {
  310   2          //        annulus_z += fabs(GORY_Z);
  311   2          annulus_s3 += fabs(last_speed) * 1; // ï¿½ï¿½ï¿½İ»ï¿½ï¿½Ö¾ï¿½ï¿½ï¿½Í±ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµï¿½ï¿½ï¿½Ä£
             -ï¿½0.1ï¿½ï¿½
  312   2        }
  313   1        if (road_type.out_annulus == 1)
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  23:56:15  PAGE 6   

  314   1        {
  315   2          annulus_t = fabs(last_speed) * 1;
  316   2          //          annulus_t=annulus_t+5;
  317   2        }
  318   1      }
  319          
  320          int8 testflag;
  321          /*************************************ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*******************************
             -******
  322          å‡½æ•°ï¼š  void Annulus_handle(void)
  323          å‚æ•°ï¼š  æ— 
  324          è¯´æ˜ï¼š  ç¯å²›å¤„ç†å‡½æ•°
  325          
  326          *æ³¨æ„ï¼šç”¨ä¸¤ä¸ªç«–ç”µæ„Ÿå¼•å¯¼è¿›ç¯
  327          è¿”å›å€¼ï¼šæ— 
  328          ******************************************************************************************/
  329          void Annulus_handle(void)
  330          {
  331   1        //å³ç¯å²›ç‰¹åŒ–æ£€æµ‹
  332   1        if ((Left_Adc + Right_Adc+Left_Shu_Adc+Right_Shu_Adc) > IN_ANNULUS_H_LIMIT 
  333   1        && (road_type.annulus == 0)
  334   1        &&(Left_Adc>3*Right_Adc)
  335   1        &&(Left_Adc>Left_Shu_Adc))
  336   1        {
  337   2          testflag = 1;
  338   2          road_type.annulus = 1;
  339   2          BUZZ_ON;
  340   2      
  341   2        }
  342   1        //    //å·¦ç¯è¿›ç¯åˆ¤æ–­
  343   1        //    if(annulus_s > DISTANCE_ANNULUS_S
  344   1        //       &&(Left_Shu_Adc>20)
  345   1        //       &&road_type.annulus==1
  346   1        //       &&road_type.in_annulus_left==0
  347   1        //       &&road_type.in_annulus_right==0
  348   1        //       &&road_type.on_annulus_left==0
  349   1        //       &&road_type.on_annulus_right==0
  350   1        //       &&road_type.out_annulus==0)
  351   1        //    {
  352   1        //      road_type.in_annulus_left = 1;
  353   1        //      P52                      = 0;
  354   1        //      testflag = 2;
  355   1        //    }
  356   1        // å³ç¯è¿›ç¯åˆ¤æ–­
  357   1        if ((annulus_s > DISTANCE_ANNULUS_S)
  358   1        && (road_type.annulus == 1) 
  359   1        && (road_type.in_annulus_left == 0) 
  360   1        && (road_type.in_annulus_right == 0) 
  361   1        && (road_type.on_annulus_left == 0) 
  362   1        && (road_type.on_annulus_right == 0) 
  363   1        && (road_type.out_annulus == 0))
  364   1        {
  365   2          testflag = 3;
  366   2          road_type.in_annulus_right = 1;
  367   2          BUZZ_ON;
  368   2          // while(1)
  369   2          // {
  370   2          //  go_motor(0,0);
  371   2          // }
  372   2        }
  373   1        //    //å·¦ç¯ä¸Šç¯å¤„ç†
  374   1        //    if(annulus_s2 > 40
  375   1        ////       &&annulus_z > DISTANCE_ANNULUS_Z
  376   1        //       &&road_type.annulus==1
  377   1        //       &&road_type.in_annulus_left==1
  378   1        //       &&road_type.in_annulus_right==0
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  23:56:15  PAGE 7   

  379   1        //       &&road_type.on_annulus_left==0
  380   1        //       &&road_type.on_annulus_right==0
  381   1        //       &&road_type.out_annulus==0)
  382   1        //    {
  383   1        //        testflag = 4;
  384   1        //        road_type.in_annulus_left =0;
  385   1        //        road_type.on_annulus_left = 1;
  386   1        //        BUZZ_ON;
  387   1        //        P52                      = 1;
  388   1        //    }
  389   1        // å³ç¯ä¸Šç¯å¤„ç†
  390   1        if (annulus_s2 > 1300 && road_type.annulus == 1 && road_type.in_annulus_left == 0 && road_type.in_annulu
             -s_right == 1 && road_type.on_annulus_left == 0 && road_type.on_annulus_right == 0 && road_type.out_annulus == 0)
  391   1        {
  392   2          testflag = 5;
  393   2          road_type.in_annulus_right = 0;
  394   2          road_type.on_annulus_right = 1;
  395   2          BUZZ_ON;
  396   2        }
  397   1        if (((road_type.on_annulus_right == 1) 
  398   1        || (road_type.on_annulus_left == 1)) 
  399   1        && Left_Adc + Right_Adc > OUT_ANNULUS_S_LIMIT 
  400   1        && annulus_s3 > 3200)
  401   1        {
  402   2          testflag = 6;
  403   2          road_type.on_annulus_right = 0;
  404   2          road_type.on_annulus_left = 0;
  405   2          road_type.out_annulus = 1;
  406   2          annulus_s = 0;
  407   2          annulus_z = 0;
  408   2          annulus_s2 = 0;
  409   2          BUZZ_ON;
  410   2        }
  411   1        // å‡ºç¯å¤„ç†
  412   1        if (annulus_t > DISTANCE_ANNULUS_T 
  413   1          && road_type.out_annulus == 1)
  414   1        {
  415   2          testflag = 7;
  416   2          road_type.out_annulus = 0;
  417   2          annulus_t = 0;
  418   2          BUZZ_OFF;
  419   2          //          while(1)
  420   2          //          {
  421   2          //            go_motor(0,0);
  422   2          //          }
  423   2        }
  424   1      }
  425          /*************************æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®è®¡ç®—æ–¹æ³•**********************
             -***
  426          å‡½æ•°ï¼š  int16 Direction_error(void)
  427          åŠŸèƒ½ï¼š  æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®
  428          å‚æ•°ï¼š  æ— 
  429          è¯´æ˜ï¼š  æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®
  430          è¿”å›å€¼ï¼šerror--è¿”å›èµ›é“åå·®
  431          ****************************************************************************************/
  432          float Direction_error(void)
  433          {
  434   1        float error = 0;
  435   1      
  436   1        if (road_type.annulus == 1)
  437   1        {
  438   2          error = Cha_x_bi_he(Left_Adc, Left_Shu_Adc*5, Right_Adc/3, Right_Shu_Adc) * 10;
  439   2          if (road_type.in_annulus_right == 1 )
  440   2          {
  441   3            error = 0.5; 
  442   3          }
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  23:56:15  PAGE 8   

  443   2          if (road_type.on_annulus_right == 1)
  444   2          {
  445   3            error = (Cha_bi_he(Right_Adc, Left_Adc, 20));
  446   3          }
  447   2          if (road_type.out_annulus == 1 && road_type.on_annulus_right == 1)
  448   2          {
  449   3            error = -3;
  450   3            road_type.annulus = 0;
  451   3          }
  452   2        }
  453   1        else
  454   1        {
  455   2          error = Cha_x_bi_he(Left_Adc, Left_Shu_Adc * 2, Right_Adc, Right_Shu_Adc * 2) * 20; 
  456   2        }
  457   1        return error;
  458   1      }
  459          
  460          /**********************************ç”µç£æ‰€æœ‰æ€»å¤„ç†***************************************
  461          å‡½æ•°ï¼š  void Get_deviation(void)
  462          åŠŸèƒ½ï¼š  ç”µç£æ‰€æœ‰æ€»å¤„ç†
  463          å‚æ•°ï¼š  æ— 
  464          è¯´æ˜ï¼š  æ”¾ä¸­æ–­è°ƒç”¨æ­¤å‡½æ•°å³å¯
  465          è¿”å›å€¼ï¼šæ— 
  466          ****************************************************************************************/
  467          void Get_deviation(void)
  468          {
  469   1      
  470   1        ADC_Collect();           
  471   1        Data_current_analyze();      
  472   1        Annulus_handle();        
  473   1        Annulus_assist();        
  474   1        Current_Dir = Direction_error(); 
  475   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1417     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       194         20
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       223     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
