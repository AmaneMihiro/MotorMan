C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:52:27  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Out_File\ADC.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\USER\src\ADC.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(..\..\Lib
                    -raries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src)
                    - DEBUG PRINT(.\Out_File\ADC.lst) TABS(2) OBJECT(.\Out_File\ADC.obj) 

stmt  level    source

    1          #include "ADC.h"
    2          #include "math.h"
    3          // int16 aim_speeda        = 730;  //ç›®æ ‡é€Ÿåº¦
    4          int16 aim_speedb = 0; // è¾“å‡ºé€Ÿåº¦ï¼ˆåŠ¨æ€æœŸæœ›é€Ÿåº¦ï¼‰=æœŸæœ›é€Ÿåº¦*æœŸæœ›å‡é€Ÿåº¦
    5          int16 aim_speedc = 0; // è½¬å¼¯å‡å°é€Ÿåº¦
    6          
    7          int16 adc_value[4]; // å‚¨å­˜ç”µæ„Ÿé‡‡é›†å€¼åŸå§‹å€¼    4ä¸ªç”µæ„Ÿ
    8          int16 AD_V[4];    // å‚¨å­˜ç”µæ„Ÿé‡‡é›†å€¼å½’ä¸€åŒ–å€¼ä¸­é—´å˜é‡ ï¼ˆæ— éœ€å…³å¿ƒï¼Œè¯·å‹¿åˆ é™¤ï¼‰
    9          // int16 adc_max[4]={90,90,90,95}; //ç”µæ„Ÿé‡‡å€¼æœ€å¤§å€¼ éœ€è¦è‡ªå·±é‡‡é›†
   10          int16 adc_max[4] = {250, 200, 175, 250};        // ç”µæ„Ÿé‡‡å€¼æœ€å¤§å€¼ éœ€è¦è‡ªå·±é‡‡é›†
   11          int16 adc_min[4] = {1, 1, 1, 1};            // ç”µæ„Ÿé‡‡å€¼æœ€å°å€¼  1,4,14,1
   12          uint8 Left_Adc, Right_Adc, Left_Shu_Adc, Right_Shu_Adc; // ç”µæ„Ÿå€¼
   13          float adc_valueM;
   14          int8 NM = 4; // ç”µæ„Ÿä¸ªæ•°
   15          
   16          // ç¯é“å‚æ•°
   17          uint16 annulus_s;
   18          uint16 annulus_s2; // ç¯å²›ç§¯åˆ†è·ç¦»2
   19          uint16 annulus_s3; // ç¯å²›ç§¯åˆ†è·ç¦»3
   20          uint16 annulus_t;
   21          uint16 annulus_z;
   22          
   23          
   24          struct ROAD_TYPE road_type = {0};
   25          int16 obstacle_Current_Dir[] = {
   26            30,
   27            31,
   28            32,
   29            33,
   30            34,
   31            35,
   32            36,
   33            37,
   34            38,
   35            39,
   36            40,
   37            41,
   38            42,
   39            43,
   40            44,
   41            45,
   42            46,
   43            47,
   44            48,
   45            49,
   46            -69,
   47            -68,
   48            -67,
   49            -66,
   50            -65,
   51            -64,
   52            -63,
   53            -62,
   54            -61,
   55            -60,
   56            -59,
   57            -58,
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:52:27  PAGE 2   

   58            -57,
   59            -56,
   60            -55,
   61            -54,
   62            -53,
   63            -52,
   64            -51,
   65            -50,
   66            -49,
   67            -48,
   68            -47,
   69            -46,
   70            -45,
   71            -44,
   72            -43,
   73            -42,
   74            -41,
   75            -40,
   76            -39,
   77            -38,
   78            -37,
   79            -36,
   80            -35,
   81            -34,
   82            -33,
   83            -32,
   84            -31,
   85            -30,
   86          };
   87          /***å½“å‰ä½ç½®*************/
   88          float Current_Dir = 0;
   89          int16 Set_gyro = 0;
   90          int16 ADC_PWM = 0;
   91          
   92          uint8 temp = 0;
   93          /***************************ç”µæ„Ÿé‡‡é›†é€šé“åˆå§‹åŒ–****************************
   94          å‡½æ•°ï¼š  void ADC_int(void)
   95          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼è¿›è¡Œåˆå§‹åŒ–
   96          å‚æ•°ï¼š  void
   97          è¯´æ˜ï¼š  ç”µæ„Ÿé‡‡é›†åˆå§‹åŒ–
   98          è¿”å›å€¼ï¼›æ— 
   99          ************************************************************************/
  100          void ADC_int(void)
  101          {
  102   1        adc_init(Left_ADC_Pin, ADC_SYSclk_DIV_2);   // åˆå§‹åŒ–P0.0ä¸ºADCåŠŸèƒ½
  103   1        adc_init(LeftXie_ADC_Pin, ADC_SYSclk_DIV_2);  // åˆå§‹åŒ–P0.1ä¸ºADCåŠŸèƒ½
  104   1        adc_init(RightXie_ADC_Pin, ADC_SYSclk_DIV_2); // åˆå§‹åŒ–P0.5ä¸ºADCåŠŸèƒ½
  105   1        adc_init(Right_ADC_Pin, ADC_SYSclk_DIV_2);    // åˆå§‹åŒ–P0.6ä¸ºADCåŠŸèƒ½
  106   1      
  107   1        adc_init(Mid_ADC_Pin, ADC_SYSclk_DIV_2); // åˆå§‹åŒ–P1.5ä¸ºADCåŠŸèƒ½
  108   1      }
  109          
  110          /***************************ä¸­å€¼æ»¤æ³¢å‡½æ•°*********************************
  111          å‡½æ•°ï¼šuint16 adc_mid(ADCN_enum adcn,ADCCH_enum ch)
  112          åŠŸèƒ½ï¼š 3æ¬¡ç”µæ„Ÿé‡‡å€¼è¿›è¡Œä¸­å€¼æ»¤æ³¢
  113          å‚æ•°ï¼š adcn        é€‰æ‹©ADCé€šé“       resolution      åˆ†è¾¨ç‡
  114          è¯´æ˜ï¼š 8ä½ADCè¾“å‡ºï¼Œ0~255ï¼ˆ2çš„8æ¬¡æ–¹ï¼‰ï¼Œ5vç”µå‹å¹³å‡åˆ†æˆ255ä»½ï¼Œåˆ†è¾¨ç‡ä¸º5/255=0.196
  115          è¿”å›å€¼ï¼›k(uint8)ä¸­é—´é‚£ä¸ªå€¼
  116          ************************************************************************/
  117          uint16 adc_mid(ADCN_enum adcn, ADCRES_enum ch)
  118          {
  119   1        uint16 i, j, k, tmp;
  120   1        i = adc_once(adcn, ch);
  121   1        j = adc_once(adcn, ch);
  122   1        k = adc_once(adcn, ch);
  123   1        if (i > j)
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:52:27  PAGE 3   

  124   1        {
  125   2          tmp = i, i = j, j = tmp;
  126   2        }
  127   1        if (k > j)
  128   1        {
  129   2          tmp = j;
  130   2        }
  131   1        else if (k > i)
  132   1        {
  133   2          tmp = k;
  134   2        }
  135   1        else
  136   1        {
  137   2          tmp = i;
  138   2        }
  139   1        return (tmp);
  140   1      }
  141          
  142          /***************************å‡å€¼æ»¤æ³¢å‡½æ•°****************************
  143          å‡½æ•°ï¼š  uint16 adc_ave(ADCN_enum adcn,ADCCH_enum ch,uint8 N)
  144          åŠŸèƒ½ï¼š  ä¸­å€¼æ»¤æ³¢åçš„5ä¸ªç”µæ„Ÿå€¼æ±‚å¹³å‡å€¼
  145          å‚æ•°ï¼š  adcn        é€‰æ‹©ADCé€šé“
  146          è¯´æ˜ï¼š  è¯¥å‡½æ•°è°ƒç”¨ä¸­å€¼æ»¤æ³¢å‡½æ•°ï¼Œå³ç”µæ„Ÿå€¼æ˜¯ä¸­ä½ç½®
  147          è¿”å›å€¼ï¼›tmp
  148          ç¤ºä¾‹ï¼š  adc_ave(ADC_P10, ADC_8BIT)-->ADCé€šé“ä¸ºP-10ï¼Œåˆ†è¾¨ç‡ä¸º8bit
  149          *******************************************************************/
  150          uint16 adc_ave(ADCN_enum adcn, ADCRES_enum ch, uint8 N)
  151          {
  152   1        uint32 tmp = 0;
  153   1        uint8 i;
  154   1        for (i = 0; i < N; i++)
  155   1        {
  156   2          tmp += adc_mid(adcn, ch);
  157   2        }
  158   1        tmp = tmp / N;
  159   1        return (tmp);
  160   1      }
  161          /***************************ç”µæ„Ÿé‡‡å€¼************************************
  162          å‡½æ•°ï¼š  void ADC_Collect()
  163          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼
  164          å‚æ•°ï¼š  void
  165          è¯´æ˜ï¼š  8ä½ADCè¾“å‡ºï¼Œ0~255ï¼ˆ2çš„8æ¬¡æ–¹ï¼‰ï¼Œ5vç”µå‹å¹³å‡åˆ†æˆ255ä»½ï¼Œåˆ†è¾¨ç‡ä¸º5/255=0.196
  166          è¿”å›å€¼ï¼›void
  167          ***********************************************************************/
  168          void ADC_Collect()
  169          {
  170   1        adc_value[0] = adc_ave(Left_ADC_Pin, ADC_8BIT, 3);     // å·¦æ¨ªç”µæ„Ÿ
  171   1        adc_value[1] = adc_ave(LeftXie_ADC_Pin, ADC_8BIT, 3);  // å·¦ç«–ç”µæ„Ÿ
  172   1        adc_value[2] = adc_ave(RightXie_ADC_Pin, ADC_8BIT, 3);   // å³ç«–ç”µæ„Ÿ
  173   1        adc_value[3] = adc_ave(Right_ADC_Pin, ADC_8BIT, 3);    // å³æ¨ªç”µæ„Ÿ
  174   1        adc_valueM = adc_ave(Mid_ADC_Pin, ADC_8BIT, 3) * 0.2246; // ç”µæºç”µå‹é‡‡é›†
  175   1      }
  176          /*********************************ç”µæ„Ÿé‡‡å€¼********************************
  177          å‡½æ•°ï¼š  void Data_current_analyze()
  178          åŠŸèƒ½ï¼š  ç”µæ„Ÿé‡‡å€¼åŸå§‹å€¼å½’ä¸€åŒ–ï¼ˆ0~100ï¼‰
  179          å‚æ•°ï¼š  void
  180          è¯´æ˜ï¼š  å½’ä¸€åŒ–å¤„ç†
  181          è¿”å›å€¼ï¼›void
  182          *************************************************************************/
  183          void Data_current_analyze()
  184          {
  185   1        uint8 i;
  186   1        for (i = 0; i < NM; i++)
  187   1        {
  188   2          AD_V[i] = ((adc_value[i] - adc_min[i]) * 100) / (adc_max[i] - adc_min[i]);
  189   2          if (AD_V[i] <= 0)
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:52:27  PAGE 4   

  190   2          {
  191   3            AD_V[i] = 0;
  192   3          }
  193   2          else if (AD_V[i] >= 100)
  194   2          {
  195   3            AD_V[i] = 100;
  196   3          }
  197   2        }
  198   1        Left_Adc = AD_V[0];    // å·¦ç”µæ„Ÿæœ€ç»ˆå€¼
  199   1        Left_Shu_Adc = AD_V[1];  // å·¦ç«–ç”µæ„Ÿæœ€ç»ˆå€¼
  200   1        Right_Shu_Adc = AD_V[2]; // å³ç«–ç”µæ„Ÿæœ€ç»ˆå€¼
  201   1        Right_Adc = AD_V[3];   // å³ç”µæ„Ÿæœ€ç»ˆå€¼
  202   1      }
  203          
  204          /*********************************å·®æ¯”å’Œå‡½æ•°**********************************
  205          å‡½æ•°ï¼š  float Cha_bi_he(int16 data1, int16 data2,int16 x)
  206          åŠŸèƒ½ï¼š  å·®æ¯”å’Œæ±‚èµ›é“åå·®
  207          å‚æ•°ï¼š  int16 data1, int16 data2,int16 x
  208          è¯´æ˜ï¼š  å·®æ¯”å’Œæ±‚èµ›é“åå·®
  209          è¿”å›å€¼ï¼›result
  210          ****************************************************************************/
  211          float Cha_bi_he(int16 data1, int16 data2, int16 x)
  212          {
  213   1        float cha;
  214   1        float he;
  215   1        float result;
  216   1      
  217   1        cha = (data1) - (data2);
  218   1        he = data1 + data2 + 1;
  219   1        result = (cha * x) / (1.0 * he);
  220   1      
  221   1        return result;
  222   1      }
  223          // å·®æ¯”å’Œå·®åŠ æƒï¼Œå˜å¼
  224          float Cha_bi_he_cha(int16 data1, int16 data2, int16 data3, int16 data4, int16 x, int16 y)
  225          {
  226   1        float cha;
  227   1        float he;
  228   1        float cha1;
  229   1        float he1;
  230   1      
  231   1        float result;
  232   1      
  233   1        cha = (data1) - (data2);
  234   1        cha1 = (data3) - (data4);
  235   1      
  236   1        he = data1 + data2 + 1;
  237   1        he1 = data3 + data4 + 1;
  238   1      
  239   1        //    result = (cha*x)/(1.0*he);
  240   1        result = ((cha * x) + (cha1 * y)) / ((1.0 * he) + (1.0 * he1));
  241   1        return result;
  242   1      }
  243          // å‘é‡å·®æ¯”å’Œ
  244          float Cha_x_bi_he(int16 data1, int16 data2, int16 data3, int16 data4)
  245          {
  246   1        float left_value;
  247   1        float right_value;
  248   1        float ad_sum;
  249   1        float ad_diff;
  250   1        float error_x;
  251   1        left_value = sqrt(data1 * data1 + data2 * data2);
  252   1      
  253   1        right_value = sqrt(data3 * data3 + data4 * data4);
  254   1      
  255   1        ad_sum = left_value + right_value + 1; // è®¡ç®—ç”µæ„Ÿä¹‹å’Œ
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:52:27  PAGE 5   

  256   1      
  257   1        // è®¡ç®—ç”µæ„Ÿä¹‹å·®
  258   1      
  259   1        ad_diff = (int16)right_value - left_value;
  260   1        error_x = ad_diff / ad_sum;
  261   1      
  262   1        return error_x;
  263   1      }
  264          /*****************************************å‡ºç•Œä¿æŠ¤å‡½æ•°*************************************
  265          å‡½æ•°ï¼š  void Out_protect()
  266          å‚æ•°ï¼š  æ— 
  267          è¯´æ˜ï¼š  é˜²æ­¢è½¦å†²å‡ºèµ›é“åæ’åä¸œè¥¿,æ£€æµ‹å‡ºèµ›é“åä¸­æ–­å¤±èƒ½ï¼Œç”µæœºåœè½¬ï¼Œæ”¾å›èµ›
             -é“ä¸­æ–­ä½¿èƒ½ç»§ç»­è·‘
  268          
  269          *æ³¨æ„ï¼šï¼ï¼ï¼å¹³æ—¶è°ƒè¯•æ—¶å¯ä»¥æ‰“å¼€ï¼ŒåŠ äº†é¿éšœå¤„ç†åéœ€è¦å…³é—­æ­¤å‡½æ•°ï¼Œä¸ç„¶æœ‰å
             -¯èƒ½æ— æ³•å®ç°é¿éšœåŠŸèƒ½ï¼ï¼ï¼
  270          è¿”å›å€¼ï¼šæ— 
  271          ******************************************************************************************/
  272          void Out_protect(void)
  273          {
  274   1        if (road_type.annulus || road_type.in_annulus_left || road_type.in_annulus_right || road_type.on_annulus
             -_left || road_type.on_annulus_right || road_type.out_annulus)
  275   1        {
  276   2          if (Left_Adc < OUTSIDE || Right_Adc < OUTSIDE)
  277   2          {
  278   3            while (1)
  279   3            {
  280   4              go_motor(-2000, -2000);
  281   4              delay_ms(400);
  282   4              while (1)
  283   4              {
  284   5                go_motor(0, 0);
  285   5                pwm_duty(PWMB_CH4_P77, 500);
  286   5                pwm_duty(PWMB_CH3_P33, 500);
  287   5              }
  288   4            }
  289   3          }
  290   2        }
  291   1      }
  292          
  293          void Annulus_assist(void)
  294          {
  295   1        if (road_type.annulus == 1 && road_type.in_annulus_right == 0 && road_type.on_annulus_right == 0 && road
             -_type.out_annulus == 0) //&&road_type.in_annulus_left==0
  296   1        {
  297   2          annulus_s += fabs(last_speed) * 1;
  298   2        }
  299   1        if (road_type.in_annulus_right == 1) // road_type.in_annulus_left==1 ||                 && road_type.on_
             -annulus_left==0ï¿½ï¿½ï¿½â£©&& road_type.on_annulus_right==0
  300   1        {
  301   2          annulus_z += fabs(GORY_Z);
  302   2          annulus_s2 += fabs(last_speed) * 1; // ï¿½ï¿½ï¿½İ»ï¿½ï¿½Ö¾ï¿½ï¿½ï¿½Í±ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµï¿½ï¿½ï¿½Ä£
             -ï¿½0.1ï¿½ï¿½
  303   2        }
  304   1        if (road_type.on_annulus_right == 1) // road_type.in_annulus_left==1 ||                 && road_type.on_
             -annulus_left==0ï¿½ï¿½ï¿½â£©&& road_type.on_annulus_right==0
  305   1        {
  306   2          //        annulus_z += fabs(GORY_Z);
  307   2          annulus_s3 += fabs(last_speed) * 1; // ï¿½ï¿½ï¿½İ»ï¿½ï¿½Ö¾ï¿½ï¿½ï¿½Í±ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Öµï¿½ï¿½ï¿½Ä£
             -ï¿½0.1ï¿½ï¿½
  308   2        }
  309   1        if (road_type.out_annulus == 1)
  310   1        {
  311   2          annulus_t = fabs(last_speed) * 1;
  312   2          //          annulus_t=annulus_t+5;
  313   2        }
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:52:27  PAGE 6   

  314   1      }
  315          
  316          int8 testflag;
  317          /*************************************ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½*******************************
             -******
  318          å‡½æ•°ï¼š  void Annulus_handle(void)
  319          å‚æ•°ï¼š  æ— 
  320          è¯´æ˜ï¼š  ç¯å²›å¤„ç†å‡½æ•°
  321          
  322          *æ³¨æ„ï¼šç”¨ä¸¤ä¸ªç«–ç”µæ„Ÿå¼•å¯¼è¿›ç¯
  323          è¿”å›å€¼ï¼šæ— 
  324          ******************************************************************************************/
  325          void Annulus_handle(void)
  326          {
  327   1        if ((Left_Adc + Right_Adc) > IN_ANNULUS_H_LIMIT && road_type.annulus == 0)
  328   1        {
  329   2          testflag = 1;
  330   2          road_type.annulus = 1;
  331   2          BUZZ_ON;
  332   2        }
  333   1        //    //å·¦ç¯è¿›ç¯åˆ¤æ–­
  334   1        //    if(annulus_s > DISTANCE_ANNULUS_S
  335   1        //       &&(Left_Shu_Adc>20)
  336   1        //       &&road_type.annulus==1
  337   1        //       &&road_type.in_annulus_left==0
  338   1        //       &&road_type.in_annulus_right==0
  339   1        //       &&road_type.on_annulus_left==0
  340   1        //       &&road_type.on_annulus_right==0
  341   1        //       &&road_type.out_annulus==0)
  342   1        //    {
  343   1        //      road_type.in_annulus_left = 1;
  344   1        //      P52                      = 0;
  345   1        //      testflag = 2;
  346   1        //    }
  347   1        // å³ç¯è¿›ç¯åˆ¤æ–­
  348   1        if (annulus_s > DISTANCE_ANNULUS_S
  349   1          //    && (Right_Shu_Adc > 20)
  350   1          && road_type.annulus == 1 && road_type.in_annulus_left == 0 && road_type.in_annulus_right == 0 && road_
             -type.on_annulus_left == 0 && road_type.on_annulus_right == 0 && road_type.out_annulus == 0)
  351   1        {
  352   2          testflag = 3;
  353   2          road_type.in_annulus_right = 1;
  354   2          BUZZ_ON;
  355   2        }
  356   1        //    //å·¦ç¯ä¸Šç¯å¤„ç†
  357   1        //    if(annulus_s2 > 40
  358   1        ////       &&annulus_z > DISTANCE_ANNULUS_Z
  359   1        //       &&road_type.annulus==1
  360   1        //       &&road_type.in_annulus_left==1
  361   1        //       &&road_type.in_annulus_right==0
  362   1        //       &&road_type.on_annulus_left==0
  363   1        //       &&road_type.on_annulus_right==0
  364   1        //       &&road_type.out_annulus==0)
  365   1        //    {
  366   1        //        testflag = 4;
  367   1        //        road_type.in_annulus_left =0;
  368   1        //        road_type.on_annulus_left = 1;
  369   1        //        BUZZ_ON;
  370   1        //        P52                      = 1;
  371   1        //    }
  372   1        // å³ç¯ä¸Šç¯å¤„ç†
  373   1        if (annulus_s2 > 1300 && road_type.annulus == 1 && road_type.in_annulus_left == 0 && road_type.in_annulu
             -s_right == 1 && road_type.on_annulus_left == 0 && road_type.on_annulus_right == 0 && road_type.out_annulus == 0)
  374   1        {
  375   2          testflag = 5;
  376   2          road_type.in_annulus_right = 0;
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:52:27  PAGE 7   

  377   2          road_type.on_annulus_right = 1;
  378   2          BUZZ_ON;
  379   2        }
  380   1        if (((road_type.on_annulus_right == 1) 
  381   1        || (road_type.on_annulus_left == 1)) 
  382   1        && Left_Adc + Right_Adc > OUT_ANNULUS_S_LIMIT 
  383   1        && annulus_s3 > 200)
  384   1        {
  385   2          testflag = 6;
  386   2          road_type.on_annulus_right = 0;
  387   2          road_type.on_annulus_left = 0;
  388   2          road_type.out_annulus = 1;
  389   2          annulus_s = 0;
  390   2          annulus_z = 0;
  391   2          annulus_s2 = 0;
  392   2          BUZZ_ON;
  393   2        }
  394   1        // å‡ºç¯å¤„ç†
  395   1        if (annulus_t > DISTANCE_ANNULUS_T 
  396   1          && road_type.out_annulus == 1)
  397   1        {
  398   2          testflag = 7;
  399   2          road_type.out_annulus = 0;
  400   2          annulus_t = 0;
  401   2          BUZZ_OFF;
  402   2          //          while(1)
  403   2          //          {
  404   2          //            go_motor(0,0);
  405   2          //          }
  406   2        }
  407   1      
  408   1        // if (annulus_t > DISTANCE_ANNULUS_T)
  409   1        // {
  410   1        //  road_type.annulus = 0;
  411   1        //  road_type.in_annulus_left = 0;
  412   1        //  road_type.in_annulus_right = 0;
  413   1        //  road_type.on_annulus_left = 0;
  414   1        //  road_type.on_annulus_right = 0;
  415   1        //  road_type.out_annulus = 0;
  416   1        //  annulus_t = 0;
  417   1      
  418   1        //  BUZZ_OFF;
  419   1        // }
  420   1      }
  421          /*************************æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®è®¡ç®—æ–¹æ³•**********************
             -***
  422          å‡½æ•°ï¼š  int16 Direction_error(void)
  423          åŠŸèƒ½ï¼š  æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®
  424          å‚æ•°ï¼š  æ— 
  425          è¯´æ˜ï¼š  æ ¹æ®èµ›é“ç±»å‹é€‰æ‹©ä¸åŒçš„æ–¹å‘åå·®
  426          è¿”å›å€¼ï¼šerror--è¿”å›èµ›é“åå·®
  427          ****************************************************************************************/
  428          float Direction_error(void)
  429          {
  430   1        float error = 0;
  431   1      
  432   1        // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  433   1        if (road_type.annulus == 1)
  434   1        {
  435   2          // ×¼ï¿½ï¿½ï¿½ë»·ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  436   2          //        if(road_type.annulus==1&&road_type.in_annulus_left==0 && road_type.in_annulus_right==0 && roa
             -d_type.on_annulus_left==0 && road_type.on_annulus_right==0 && road_type.out_annulus==0)
  437   2          //        {
  438   2          //          error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*20;
  439   2          //        //ï¿½ï¿½ï¿½ó»·µï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  440   2          //        if(road_type.in_annulus_left ==1 && road_type.on_annulus_left==0 )
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:52:27  PAGE 8   

  441   2          //        {
  442   2          //            //error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*20;
  443   2          //            error = -15;
  444   2          //          road_type.annulus=0;//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö¾Î»ï¿½ï¿½ï¿½ï¿½
  445   2          //        }
  446   2          // ï¿½ï¿½ï¿½Ò»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  447   2          if (road_type.in_annulus_right == 1 )
  448   2          {
  449   3            // error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*20;          // error = 3;
  450   3            error = 0.5; // ï¿½ß¼ï¿½ï¿½à·´ï¿½ï¿½Ñ­ï¿½ï¿½
  451   3      
  452   3            //        while(1)//ï¿½ï¿½Ç½Úµï¿½2
  453   3            //          {
  454   3            //            go_motor(0,0);
  455   3            //          }
  456   3          }
  457   2          // ï¿½Ú»ï¿½ï¿½ï¿½Æ«ï¿½ï¿½
  458   2          if (road_type.on_annulus_right == 1)
  459   2          {
  460   3            //          error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*20;
  461   3            error = (Cha_bi_he(Right_Adc, Left_Adc, 20));
  462   3      
  463   3            //        while(1)//ï¿½ï¿½ï¿½ï¿½Ñ­ï¿½ï¿½ï¿½Úµï¿½4
  464   3            //          {
  465   3            //            go_motor(0,0);
  466   3            //          }
  467   3          }
  468   2          // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½ï¿½ï¿½ï¿½
  469   2          if (road_type.out_annulus == 1 && road_type.on_annulus_right == 1)
  470   2          {
  471   3            //            error = Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc)*7;
  472   3            error = -3;
  473   3            //          error = Cha_bi_he(Right_Adc,Left_Adc,5);
  474   3            road_type.annulus = 0; // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö¾Î»ï¿½ï¿½ï¿½ï¿½
  475   3                         //       while(1)//ï¿½ï¿½ï¿½ï¿½ï¿½Úµï¿½6
  476   3                         //         {
  477   3                         //           go_motor(0,0);
  478   3                         //         }
  479   3          }
  480   2        }
  481   1        // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½î´¦ï¿½ï¿½
  482   1      
  483   1        else
  484   1        {
  485   2      
  486   2          //    aim_speed = ZxjsWdjs(Cha_x_bi_he(Left_Adc,Left_Shu_Adc,Right_Adc,Right_Shu_Adc),400)+100;
  487   2          error = Cha_x_bi_he(Left_Adc, Left_Shu_Adc * 2, Right_Adc, Right_Shu_Adc * 2) * 20; // ï¿½ï¿½Ä»ï¿½ï¿½Ê¾
             -ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ«ï¿½ï¿½Öµ
  488   2      
  489   2          //      errorh=1.0f/exp(errors*errors);                       //ï¿½ï¿½ï¿½Ùºï¿½ï¿½ï¿½
  490   2          //      aim_speedb=aim_speed*errorh;                        //ï¿½ï¿½Ì¬ï¿½ï¿½ï¿½ï¿½ï¿½Ù¶È£ï¿½Ö±ï¿½ï¿½ï¿½ï¿½Ë¥ï¿½ï¿½ï¿½ï
             -¿½ï¿½Ë¥ï¿½ï¿½ï¿½ï¿½
  491   2                      //      if(Left_Adc==0&&Left_Shu_Adc==0&&Right_Adc==0&&Right_Shu_Adc==0)
  492   2                      //      {
  493   2                      //      aim_speedb = -10;                             //ï¿½ï¿½ï¿½ßµï¿½ï¿½ï¿½
  494   2                      //      }
  495   2      
  496   2          //  }
  497   2        }
  498   1        return error;
  499   1      }
  500          
  501          /**********************************ç”µç£æ‰€æœ‰æ€»å¤„ç†***************************************
  502          å‡½æ•°ï¼š  void Get_deviation(void)
  503          åŠŸèƒ½ï¼š  ç”µç£æ‰€æœ‰æ€»å¤„ç†
  504          å‚æ•°ï¼š  æ— 
C251 COMPILER V5.60.0,  ADC                                                                20/03/25  18:52:27  PAGE 9   

  505          è¯´æ˜ï¼š  æ”¾ä¸­æ–­è°ƒç”¨æ­¤å‡½æ•°å³å¯
  506          è¿”å›å€¼ï¼šæ— 
  507          ****************************************************************************************/
  508          void Get_deviation(void)
  509          {
  510   1      
  511   1        ADC_Collect();           
  512   1        Data_current_analyze();      
  513   1        Annulus_handle();        
  514   1        Annulus_assist();        
  515   1        Current_Dir = Direction_error(); 
  516   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1386     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       194         20
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       203     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
